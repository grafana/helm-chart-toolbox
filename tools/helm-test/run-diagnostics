#!/usr/bin/env bash
set -eo pipefail

usage() {
  echo "USAGE: run-diagnostics <phase> [<test-dir>] [--result <success|failure>]"
  echo ""
  echo "Runs diagnostics defined in test-plan.yaml for the specified phase."
  echo ""
  echo "Arguments:"
  echo "  <phase>              - Diagnostic phase to execute. One of:"
  echo "                         beforeDependencies, afterDependencies, beforeSubject,"
  echo "                         afterSubject, beforeTest, afterTest, final."
  echo "  <test-dir>           - The test directory. Defaults to the current directory."
  echo ""
  echo "Options:"
  echo "  --result <status>    - Previous step result (success or failure). Defaults to failure."
  echo "  -h, --help           - Show this help text."
}

to_lower() {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

is_true() {
  case "$(to_lower "$1")" in
    1|true|yes|on) return 0 ;;
    *) return 1 ;;
  esac
}

should_run_diagnostic() {
  local whenLower
  whenLower=$(to_lower "$1")
  local result="$2"

  case "${whenLower}" in
    ""|always) return 0 ;;
    onfailure) [[ "${result}" == "failure" ]] && return 0 || return 1 ;;
    onsuccess) [[ "${result}" == "success" ]] && return 0 || return 1 ;;
    *)
      echo "Skipping diagnostic with unsupported 'when' value: ${1}" >&2
      return 1
      ;;
  esac
}

run_command_with_grouping() {
  local grouping="$1"
  local title="$2"
  shift 2
  local -a cmd=("$@")

  if [ "${grouping}" = "github" ]; then
    echo "::group::${title}"
  fi

  echo "##### ${title}"
  echo "+ ${cmd[*]}"
  set +e
  "${cmd[@]}"
  local exitCode=$?
  set -e
  if [ "${exitCode}" -ne 0 ]; then
    echo "Command failed with exit code ${exitCode}" >&2
  fi

  if [ "${grouping}" = "github" ]; then
    echo "::endgroup::"
  fi
}

phase=""
testDir=""
result="failure"

while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|-help|--help)
      usage
      exit 0
      ;;
    --result)
      if [ "$#" -lt 2 ]; then
        echo "Missing value for --result" >&2
        usage
        exit 1
      fi
      result="$2"
      shift
      ;;
    *)
      if [ -z "${phase}" ]; then
        phase="$1"
      elif [ -z "${testDir}" ]; then
        testDir="$1"
      else
        echo "Unexpected argument: $1" >&2
        usage
        exit 1
      fi
      ;;
  esac
  shift
done

if [ -z "${phase}" ]; then
  echo "Phase is required." >&2
  usage
  exit 1
fi

case "${phase}" in
  beforeDependencies|afterDependencies|beforeSubject|afterSubject|beforeTest|afterTest|final)
    ;;
  *)
    echo "Invalid phase: ${phase}" >&2
    usage
    exit 1
    ;;
esac

result=$(to_lower "${result}")
case "${result}" in
  success|failure)
    ;;
  *)
    echo "Invalid value for --result: ${result}" >&2
    usage
    exit 1
    ;;
esac

if [ -z "${testDir}" ]; then
  testDir=$(pwd)
elif [ ! -d "${testDir}" ]; then
  echo "Argument is not a valid directory: ${testDir}" >&2
  usage
  exit 1
fi

testPlan=$(realpath "${testDir}/test-plan.yaml")
if [ ! -f "${testPlan}" ]; then
  echo "test-plan.yaml file not found in ${testDir}" >&2
  usage
  exit 1
fi

subjectNamespace=$(yq eval -r '.subject.namespace // ""' "${testPlan}")
if [ -z "${subjectNamespace}" ]; then
  subjectNamespace="toolbox"
fi

diagnosticCount=$(yq eval '.diagnostics // [] | length' "${testPlan}")
if [ "${diagnosticCount}" -eq 0 ]; then
  echo "No diagnostics defined in ${testPlan}."
  exit 0
fi

matchingDiagnostics=0

for diagnosticIndex in $(seq 0 $((diagnosticCount - 1))); do
  diagnosticPhase=$(yq eval -r ".diagnostics[${diagnosticIndex}].phase // \"final\"" "${testPlan}")
  if [ "${diagnosticPhase}" != "${phase}" ]; then
    continue
  fi

  diagnosticWhen=$(yq eval -r ".diagnostics[${diagnosticIndex}].when // \"onFailure\"" "${testPlan}")
  if ! should_run_diagnostic "${diagnosticWhen}" "${result}"; then
    continue
  fi

  diagnosticName=$(yq eval -r ".diagnostics[${diagnosticIndex}].name // \"Diagnostic $((diagnosticIndex + 1))\"" "${testPlan}")
  useLogGrouping=$(yq eval -r ".diagnostics[${diagnosticIndex}].useLogGrouping // true" "${testPlan}")
  groupingMode="plain"
  if is_true "${useLogGrouping}" && [ -n "${GITHUB_ACTIONS:-}" ]; then
    groupingMode="github"
  fi

  targetCount=$(yq eval ".diagnostics[${diagnosticIndex}].targets // [] | length" "${testPlan}")
  if [ "${targetCount}" -eq 0 ]; then
    echo "Diagnostic '${diagnosticName}' has no targets defined; skipping."
    continue
  fi

  matchingDiagnostics=$((matchingDiagnostics + 1))

  echo
  echo "### Diagnostic: ${diagnosticName}"

  for targetIndex in $(seq 0 $((targetCount - 1))); do
    namespace=$(yq eval -r ".diagnostics[${diagnosticIndex}].targets[${targetIndex}].namespace // \"${subjectNamespace}\"" "${testPlan}")
    targetLabel=$(yq eval -r ".diagnostics[${diagnosticIndex}].targets[${targetIndex}].name // \"Target $((targetIndex + 1))\"" "${testPlan}")

    echo "#### Target: ${targetLabel} (namespace: ${namespace})"

    actionPerformed=false

    objectsCount=$(yq eval ".diagnostics[${diagnosticIndex}].targets[${targetIndex}].objects // [] | length" "${testPlan}")
    if [ "${objectsCount}" -gt 0 ]; then
      actionPerformed=true
      for objectIndex in $(seq 0 $((objectsCount - 1))); do
        resource=$(yq eval -r ".diagnostics[${diagnosticIndex}].targets[${targetIndex}].objects[${objectIndex}]" "${testPlan}")
        if [ -n "${resource}" ] && [ "${resource}" != "null" ]; then
          title="${diagnosticName}: ${resource} in namespace ${namespace}"
          run_command_with_grouping "${groupingMode}" "${title}" kubectl get "${resource}" --namespace "${namespace}" -o yaml
        fi
      done
    fi

    if is_true "$(yq eval -r ".diagnostics[${diagnosticIndex}].targets[${targetIndex}].events // false" "${testPlan}")"; then
      actionPerformed=true
      title="${diagnosticName}: events in namespace ${namespace}"
      run_command_with_grouping "${groupingMode}" "${title}" kubectl get events --namespace "${namespace}" --sort-by=.lastTimestamp
    fi

    if is_true "$(yq eval -r ".diagnostics[${diagnosticIndex}].targets[${targetIndex}].logs // false" "${testPlan}")"; then
      actionPerformed=true
      if ! podList=$(kubectl get pods --namespace "${namespace}" -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'); then
        echo "Failed to list pods in namespace ${namespace}" >&2
      elif [ -z "${podList}" ]; then
        echo "No pods found in namespace ${namespace}"
      else
        printf '%s\n' "${podList}" | while IFS= read -r podName; do
          [ -z "${podName}" ] && continue
          title="${diagnosticName}: logs for pod ${podName} (namespace ${namespace})"
          run_command_with_grouping "${groupingMode}" "${title}" kubectl logs --namespace "${namespace}" "${podName}" --all-containers --tail 200
        done
      fi
    fi

    if [ "${actionPerformed}" = false ]; then
      echo "No diagnostic actions configured for this target."
    fi
  done
done

if [ "${matchingDiagnostics}" -eq 0 ]; then
  echo "No diagnostics to run for phase '${phase}' with result '${result}'."
fi
